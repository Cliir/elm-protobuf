-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: simple.proto

module Simple exposing (..)

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE
import Google.Protobuf.Wrappers exposing (..)
import Dir.Other_dir exposing (..)
import Other exposing (..)


type Colour
    = ColourUnspecified -- 0
    | Red -- 1
    | Green -- 2
    | Blue -- 3


colourDecoder : JD.Decoder Colour
colourDecoder =
    let
        lookup s =
            case s of
                "COLOUR_UNSPECIFIED" ->
                    ColourUnspecified

                "RED" ->
                    Red

                "GREEN" ->
                    Green

                "BLUE" ->
                    Blue

                _ ->
                    ColourUnspecified
    in
        JD.map lookup JD.string


colourDefault : Colour
colourDefault = ColourUnspecified


colourEncoder : Colour -> JE.Value
colourEncoder v =
    let
        lookup s =
            case s of
                ColourUnspecified ->
                    "COLOUR_UNSPECIFIED"

                Red ->
                    "RED"

                Green ->
                    "GREEN"

                Blue ->
                    "BLUE"

    in
        JE.string <| lookup v


type alias Simple =
    { int32Field : Int -- 1
    }


simpleDecoder : JD.Decoder Simple
simpleDecoder =
    JD.lazy <| \_ -> decode Simple
        |> required "int32Field" JD.int 0


simpleEncoder : Simple -> JE.Value
simpleEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "int32Field" JE.int 0 v.int32Field)
        ]


type alias Foo =
    { s : Maybe Simple -- 1
    , ss : List Simple -- 2
    , colour : Colour -- 3
    , colours : List Colour -- 4
    , singleIntField : Int -- 5
    , repeatedIntField : List Int -- 6
    , bytesField : Bytes -- 9
    , stringValueField : Maybe StringValue -- 10
    , otherField : Maybe Other -- 11
    , otherDirField : Maybe OtherDir -- 12
    , timestampField : Maybe Timestamp -- 13
    , oo : Oo
    }


type Oo
    = OoUnspecified
    | Oo1 Int
    | Oo2 Bool


ooDecoder : JD.Decoder Oo
ooDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Oo1 (JD.field "oo1" JD.int)
        , JD.map Oo2 (JD.field "oo2" JD.bool)
        , JD.succeed OoUnspecified
        ]


ooEncoder : Oo -> Maybe ( String, JE.Value )
ooEncoder v =
    case v of
        OoUnspecified ->
            Nothing
        Oo1 x ->
            Just ( "oo1", JE.int x )
        Oo2 x ->
            Just ( "oo2", JE.bool x )


fooDecoder : JD.Decoder Foo
fooDecoder =
    JD.lazy <| \_ -> decode Foo
        |> optional "s" simpleDecoder
        |> repeated "ss" simpleDecoder
        |> required "colour" colourDecoder colourDefault
        |> repeated "colours" colourDecoder
        |> required "singleIntField" JD.int 0
        |> repeated "repeatedIntField" JD.int
        |> required "bytesField" bytesFieldDecoder []
        |> optional "stringValueField" stringValueDecoder
        |> optional "otherField" otherDecoder
        |> optional "otherDirField" otherDirDecoder
        |> optional "timestampField" timestampDecoder
        |> field ooDecoder


fooEncoder : Foo -> JE.Value
fooEncoder v =
    JE.object <| List.filterMap identity <|
        [ (optionalEncoder "s" simpleEncoder v.s)
        , (repeatedFieldEncoder "ss" simpleEncoder v.ss)
        , (requiredFieldEncoder "colour" colourEncoder colourDefault v.colour)
        , (repeatedFieldEncoder "colours" colourEncoder v.colours)
        , (requiredFieldEncoder "singleIntField" JE.int 0 v.singleIntField)
        , (repeatedFieldEncoder "repeatedIntField" JE.int v.repeatedIntField)
        , (requiredFieldEncoder "bytesField" bytesFieldEncoder [] v.bytesField)
        , (optionalEncoder "stringValueField" stringValueEncoder v.stringValueField)
        , (optionalEncoder "otherField" otherEncoder v.otherField)
        , (optionalEncoder "otherDirField" otherDirEncoder v.otherDirField)
        , (optionalEncoder "timestampField" timestampEncoder v.timestampField)
        , (ooEncoder v.oo)
        ]


type alias Wrappers =
    { int32ValueField : Maybe Int32Value -- 1
    , int64ValueField : Maybe Int64Value -- 2
    , uInt32ValueField : Maybe UInt32Value -- 3
    , uInt64ValueField : Maybe UInt64Value -- 4
    , doubleValueField : Maybe DoubleValue -- 5
    , floatValueField : Maybe FloatValue -- 6
    , boolValueField : Maybe BoolValue -- 7
    , stringValueField : Maybe StringValue -- 8
    , bytesValueField : Maybe BytesValue -- 9
    }


wrappersDecoder : JD.Decoder Wrappers
wrappersDecoder =
    JD.lazy <| \_ -> decode Wrappers
        |> optional "int32ValueField" int32ValueDecoder
        |> optional "int64ValueField" int64ValueDecoder
        |> optional "uInt32ValueField" uInt32ValueDecoder
        |> optional "uInt64ValueField" uInt64ValueDecoder
        |> optional "doubleValueField" doubleValueDecoder
        |> optional "floatValueField" floatValueDecoder
        |> optional "boolValueField" boolValueDecoder
        |> optional "stringValueField" stringValueDecoder
        |> optional "bytesValueField" bytesValueDecoder


wrappersEncoder : Wrappers -> JE.Value
wrappersEncoder v =
    JE.object <| List.filterMap identity <|
        [ (optionalEncoder "int32ValueField" int32ValueEncoder v.int32ValueField)
        , (optionalEncoder "int64ValueField" int64ValueEncoder v.int64ValueField)
        , (optionalEncoder "uInt32ValueField" uInt32ValueEncoder v.uInt32ValueField)
        , (optionalEncoder "uInt64ValueField" uInt64ValueEncoder v.uInt64ValueField)
        , (optionalEncoder "doubleValueField" doubleValueEncoder v.doubleValueField)
        , (optionalEncoder "floatValueField" floatValueEncoder v.floatValueField)
        , (optionalEncoder "boolValueField" boolValueEncoder v.boolValueField)
        , (optionalEncoder "stringValueField" stringValueEncoder v.stringValueField)
        , (optionalEncoder "bytesValueField" bytesValueEncoder v.bytesValueField)
        ]
